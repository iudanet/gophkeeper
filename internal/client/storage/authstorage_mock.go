// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storage

import (
	"context"
	"sync"
)

// Ensure, that AuthStorageMock does implement AuthStorage.
// If this is not the case, regenerate this file with moq.
var _ AuthStorage = &AuthStorageMock{}

// AuthStorageMock is a mock implementation of AuthStorage.
//
//	func TestSomethingThatUsesAuthStorage(t *testing.T) {
//
//		// make and configure a mocked AuthStorage
//		mockedAuthStorage := &AuthStorageMock{
//			DeleteAuthFunc: func(ctx context.Context) error {
//				panic("mock out the DeleteAuth method")
//			},
//			GetAuthFunc: func(ctx context.Context) (*AuthData, error) {
//				panic("mock out the GetAuth method")
//			},
//			IsAuthenticatedFunc: func(ctx context.Context) (bool, error) {
//				panic("mock out the IsAuthenticated method")
//			},
//			SaveAuthFunc: func(ctx context.Context, auth *AuthData) error {
//				panic("mock out the SaveAuth method")
//			},
//		}
//
//		// use mockedAuthStorage in code that requires AuthStorage
//		// and then make assertions.
//
//	}
type AuthStorageMock struct {
	// DeleteAuthFunc mocks the DeleteAuth method.
	DeleteAuthFunc func(ctx context.Context) error

	// GetAuthFunc mocks the GetAuth method.
	GetAuthFunc func(ctx context.Context) (*AuthData, error)

	// IsAuthenticatedFunc mocks the IsAuthenticated method.
	IsAuthenticatedFunc func(ctx context.Context) (bool, error)

	// SaveAuthFunc mocks the SaveAuth method.
	SaveAuthFunc func(ctx context.Context, auth *AuthData) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteAuth holds details about calls to the DeleteAuth method.
		DeleteAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAuth holds details about calls to the GetAuth method.
		GetAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IsAuthenticated holds details about calls to the IsAuthenticated method.
		IsAuthenticated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SaveAuth holds details about calls to the SaveAuth method.
		SaveAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Auth is the auth argument value.
			Auth *AuthData
		}
	}
	lockDeleteAuth      sync.RWMutex
	lockGetAuth         sync.RWMutex
	lockIsAuthenticated sync.RWMutex
	lockSaveAuth        sync.RWMutex
}

// DeleteAuth calls DeleteAuthFunc.
func (mock *AuthStorageMock) DeleteAuth(ctx context.Context) error {
	if mock.DeleteAuthFunc == nil {
		panic("AuthStorageMock.DeleteAuthFunc: method is nil but AuthStorage.DeleteAuth was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteAuth.Lock()
	mock.calls.DeleteAuth = append(mock.calls.DeleteAuth, callInfo)
	mock.lockDeleteAuth.Unlock()
	return mock.DeleteAuthFunc(ctx)
}

// DeleteAuthCalls gets all the calls that were made to DeleteAuth.
// Check the length with:
//
//	len(mockedAuthStorage.DeleteAuthCalls())
func (mock *AuthStorageMock) DeleteAuthCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDeleteAuth.RLock()
	calls = mock.calls.DeleteAuth
	mock.lockDeleteAuth.RUnlock()
	return calls
}

// GetAuth calls GetAuthFunc.
func (mock *AuthStorageMock) GetAuth(ctx context.Context) (*AuthData, error) {
	if mock.GetAuthFunc == nil {
		panic("AuthStorageMock.GetAuthFunc: method is nil but AuthStorage.GetAuth was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAuth.Lock()
	mock.calls.GetAuth = append(mock.calls.GetAuth, callInfo)
	mock.lockGetAuth.Unlock()
	return mock.GetAuthFunc(ctx)
}

// GetAuthCalls gets all the calls that were made to GetAuth.
// Check the length with:
//
//	len(mockedAuthStorage.GetAuthCalls())
func (mock *AuthStorageMock) GetAuthCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAuth.RLock()
	calls = mock.calls.GetAuth
	mock.lockGetAuth.RUnlock()
	return calls
}

// IsAuthenticated calls IsAuthenticatedFunc.
func (mock *AuthStorageMock) IsAuthenticated(ctx context.Context) (bool, error) {
	if mock.IsAuthenticatedFunc == nil {
		panic("AuthStorageMock.IsAuthenticatedFunc: method is nil but AuthStorage.IsAuthenticated was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockIsAuthenticated.Lock()
	mock.calls.IsAuthenticated = append(mock.calls.IsAuthenticated, callInfo)
	mock.lockIsAuthenticated.Unlock()
	return mock.IsAuthenticatedFunc(ctx)
}

// IsAuthenticatedCalls gets all the calls that were made to IsAuthenticated.
// Check the length with:
//
//	len(mockedAuthStorage.IsAuthenticatedCalls())
func (mock *AuthStorageMock) IsAuthenticatedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockIsAuthenticated.RLock()
	calls = mock.calls.IsAuthenticated
	mock.lockIsAuthenticated.RUnlock()
	return calls
}

// SaveAuth calls SaveAuthFunc.
func (mock *AuthStorageMock) SaveAuth(ctx context.Context, auth *AuthData) error {
	if mock.SaveAuthFunc == nil {
		panic("AuthStorageMock.SaveAuthFunc: method is nil but AuthStorage.SaveAuth was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Auth *AuthData
	}{
		Ctx:  ctx,
		Auth: auth,
	}
	mock.lockSaveAuth.Lock()
	mock.calls.SaveAuth = append(mock.calls.SaveAuth, callInfo)
	mock.lockSaveAuth.Unlock()
	return mock.SaveAuthFunc(ctx, auth)
}

// SaveAuthCalls gets all the calls that were made to SaveAuth.
// Check the length with:
//
//	len(mockedAuthStorage.SaveAuthCalls())
func (mock *AuthStorageMock) SaveAuthCalls() []struct {
	Ctx  context.Context
	Auth *AuthData
} {
	var calls []struct {
		Ctx  context.Context
		Auth *AuthData
	}
	mock.lockSaveAuth.RLock()
	calls = mock.calls.SaveAuth
	mock.lockSaveAuth.RUnlock()
	return calls
}
