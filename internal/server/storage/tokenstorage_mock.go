// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storage

import (
	"context"
	"github.com/iudanet/gophkeeper/internal/models"
	"sync"
)

// Ensure, that TokenStorageMock does implement TokenStorage.
// If this is not the case, regenerate this file with moq.
var _ TokenStorage = &TokenStorageMock{}

// TokenStorageMock is a mock implementation of TokenStorage.
//
//	func TestSomethingThatUsesTokenStorage(t *testing.T) {
//
//		// make and configure a mocked TokenStorage
//		mockedTokenStorage := &TokenStorageMock{
//			DeleteExpiredTokensFunc: func(ctx context.Context) (int, error) {
//				panic("mock out the DeleteExpiredTokens method")
//			},
//			DeleteRefreshTokenFunc: func(ctx context.Context, token string) error {
//				panic("mock out the DeleteRefreshToken method")
//			},
//			DeleteUserTokensFunc: func(ctx context.Context, userID string) (int, error) {
//				panic("mock out the DeleteUserTokens method")
//			},
//			GetRefreshTokenFunc: func(ctx context.Context, token string) (*models.RefreshToken, error) {
//				panic("mock out the GetRefreshToken method")
//			},
//			GetUserTokensFunc: func(ctx context.Context, userID string) ([]*models.RefreshToken, error) {
//				panic("mock out the GetUserTokens method")
//			},
//			SaveRefreshTokenFunc: func(ctx context.Context, token *models.RefreshToken) error {
//				panic("mock out the SaveRefreshToken method")
//			},
//		}
//
//		// use mockedTokenStorage in code that requires TokenStorage
//		// and then make assertions.
//
//	}
type TokenStorageMock struct {
	// DeleteExpiredTokensFunc mocks the DeleteExpiredTokens method.
	DeleteExpiredTokensFunc func(ctx context.Context) (int, error)

	// DeleteRefreshTokenFunc mocks the DeleteRefreshToken method.
	DeleteRefreshTokenFunc func(ctx context.Context, token string) error

	// DeleteUserTokensFunc mocks the DeleteUserTokens method.
	DeleteUserTokensFunc func(ctx context.Context, userID string) (int, error)

	// GetRefreshTokenFunc mocks the GetRefreshToken method.
	GetRefreshTokenFunc func(ctx context.Context, token string) (*models.RefreshToken, error)

	// GetUserTokensFunc mocks the GetUserTokens method.
	GetUserTokensFunc func(ctx context.Context, userID string) ([]*models.RefreshToken, error)

	// SaveRefreshTokenFunc mocks the SaveRefreshToken method.
	SaveRefreshTokenFunc func(ctx context.Context, token *models.RefreshToken) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteExpiredTokens holds details about calls to the DeleteExpiredTokens method.
		DeleteExpiredTokens []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DeleteRefreshToken holds details about calls to the DeleteRefreshToken method.
		DeleteRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// DeleteUserTokens holds details about calls to the DeleteUserTokens method.
		DeleteUserTokens []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
		}
		// GetRefreshToken holds details about calls to the GetRefreshToken method.
		GetRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// GetUserTokens holds details about calls to the GetUserTokens method.
		GetUserTokens []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
		}
		// SaveRefreshToken holds details about calls to the SaveRefreshToken method.
		SaveRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token *models.RefreshToken
		}
	}
	lockDeleteExpiredTokens sync.RWMutex
	lockDeleteRefreshToken  sync.RWMutex
	lockDeleteUserTokens    sync.RWMutex
	lockGetRefreshToken     sync.RWMutex
	lockGetUserTokens       sync.RWMutex
	lockSaveRefreshToken    sync.RWMutex
}

// DeleteExpiredTokens calls DeleteExpiredTokensFunc.
func (mock *TokenStorageMock) DeleteExpiredTokens(ctx context.Context) (int, error) {
	if mock.DeleteExpiredTokensFunc == nil {
		panic("TokenStorageMock.DeleteExpiredTokensFunc: method is nil but TokenStorage.DeleteExpiredTokens was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteExpiredTokens.Lock()
	mock.calls.DeleteExpiredTokens = append(mock.calls.DeleteExpiredTokens, callInfo)
	mock.lockDeleteExpiredTokens.Unlock()
	return mock.DeleteExpiredTokensFunc(ctx)
}

// DeleteExpiredTokensCalls gets all the calls that were made to DeleteExpiredTokens.
// Check the length with:
//
//	len(mockedTokenStorage.DeleteExpiredTokensCalls())
func (mock *TokenStorageMock) DeleteExpiredTokensCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDeleteExpiredTokens.RLock()
	calls = mock.calls.DeleteExpiredTokens
	mock.lockDeleteExpiredTokens.RUnlock()
	return calls
}

// DeleteRefreshToken calls DeleteRefreshTokenFunc.
func (mock *TokenStorageMock) DeleteRefreshToken(ctx context.Context, token string) error {
	if mock.DeleteRefreshTokenFunc == nil {
		panic("TokenStorageMock.DeleteRefreshTokenFunc: method is nil but TokenStorage.DeleteRefreshToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockDeleteRefreshToken.Lock()
	mock.calls.DeleteRefreshToken = append(mock.calls.DeleteRefreshToken, callInfo)
	mock.lockDeleteRefreshToken.Unlock()
	return mock.DeleteRefreshTokenFunc(ctx, token)
}

// DeleteRefreshTokenCalls gets all the calls that were made to DeleteRefreshToken.
// Check the length with:
//
//	len(mockedTokenStorage.DeleteRefreshTokenCalls())
func (mock *TokenStorageMock) DeleteRefreshTokenCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockDeleteRefreshToken.RLock()
	calls = mock.calls.DeleteRefreshToken
	mock.lockDeleteRefreshToken.RUnlock()
	return calls
}

// DeleteUserTokens calls DeleteUserTokensFunc.
func (mock *TokenStorageMock) DeleteUserTokens(ctx context.Context, userID string) (int, error) {
	if mock.DeleteUserTokensFunc == nil {
		panic("TokenStorageMock.DeleteUserTokensFunc: method is nil but TokenStorage.DeleteUserTokens was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockDeleteUserTokens.Lock()
	mock.calls.DeleteUserTokens = append(mock.calls.DeleteUserTokens, callInfo)
	mock.lockDeleteUserTokens.Unlock()
	return mock.DeleteUserTokensFunc(ctx, userID)
}

// DeleteUserTokensCalls gets all the calls that were made to DeleteUserTokens.
// Check the length with:
//
//	len(mockedTokenStorage.DeleteUserTokensCalls())
func (mock *TokenStorageMock) DeleteUserTokensCalls() []struct {
	Ctx    context.Context
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
	}
	mock.lockDeleteUserTokens.RLock()
	calls = mock.calls.DeleteUserTokens
	mock.lockDeleteUserTokens.RUnlock()
	return calls
}

// GetRefreshToken calls GetRefreshTokenFunc.
func (mock *TokenStorageMock) GetRefreshToken(ctx context.Context, token string) (*models.RefreshToken, error) {
	if mock.GetRefreshTokenFunc == nil {
		panic("TokenStorageMock.GetRefreshTokenFunc: method is nil but TokenStorage.GetRefreshToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockGetRefreshToken.Lock()
	mock.calls.GetRefreshToken = append(mock.calls.GetRefreshToken, callInfo)
	mock.lockGetRefreshToken.Unlock()
	return mock.GetRefreshTokenFunc(ctx, token)
}

// GetRefreshTokenCalls gets all the calls that were made to GetRefreshToken.
// Check the length with:
//
//	len(mockedTokenStorage.GetRefreshTokenCalls())
func (mock *TokenStorageMock) GetRefreshTokenCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockGetRefreshToken.RLock()
	calls = mock.calls.GetRefreshToken
	mock.lockGetRefreshToken.RUnlock()
	return calls
}

// GetUserTokens calls GetUserTokensFunc.
func (mock *TokenStorageMock) GetUserTokens(ctx context.Context, userID string) ([]*models.RefreshToken, error) {
	if mock.GetUserTokensFunc == nil {
		panic("TokenStorageMock.GetUserTokensFunc: method is nil but TokenStorage.GetUserTokens was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserTokens.Lock()
	mock.calls.GetUserTokens = append(mock.calls.GetUserTokens, callInfo)
	mock.lockGetUserTokens.Unlock()
	return mock.GetUserTokensFunc(ctx, userID)
}

// GetUserTokensCalls gets all the calls that were made to GetUserTokens.
// Check the length with:
//
//	len(mockedTokenStorage.GetUserTokensCalls())
func (mock *TokenStorageMock) GetUserTokensCalls() []struct {
	Ctx    context.Context
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
	}
	mock.lockGetUserTokens.RLock()
	calls = mock.calls.GetUserTokens
	mock.lockGetUserTokens.RUnlock()
	return calls
}

// SaveRefreshToken calls SaveRefreshTokenFunc.
func (mock *TokenStorageMock) SaveRefreshToken(ctx context.Context, token *models.RefreshToken) error {
	if mock.SaveRefreshTokenFunc == nil {
		panic("TokenStorageMock.SaveRefreshTokenFunc: method is nil but TokenStorage.SaveRefreshToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token *models.RefreshToken
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockSaveRefreshToken.Lock()
	mock.calls.SaveRefreshToken = append(mock.calls.SaveRefreshToken, callInfo)
	mock.lockSaveRefreshToken.Unlock()
	return mock.SaveRefreshTokenFunc(ctx, token)
}

// SaveRefreshTokenCalls gets all the calls that were made to SaveRefreshToken.
// Check the length with:
//
//	len(mockedTokenStorage.SaveRefreshTokenCalls())
func (mock *TokenStorageMock) SaveRefreshTokenCalls() []struct {
	Ctx   context.Context
	Token *models.RefreshToken
} {
	var calls []struct {
		Ctx   context.Context
		Token *models.RefreshToken
	}
	mock.lockSaveRefreshToken.RLock()
	calls = mock.calls.SaveRefreshToken
	mock.lockSaveRefreshToken.RUnlock()
	return calls
}
